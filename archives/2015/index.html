<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>归档: 2015 | Snippet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="Jinyu Li">
  
  
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Snippet">
<meta property="og:url" content="http://www.mrsnippet.com/archives/2015/index.html">
<meta property="og:site_name" content="Snippet">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Snippet">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Snippet" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-42937397-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Snippet</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">


<h2 class="archives-title"><span>2015</span></h2>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/03/02/reactive/">
  <time datetime="2015-03-02T06:06:33.000Z">
    Mar 2 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/03/02/reactive/">reactive</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>最近想仔细看看ReactiveCocoa，其实之前就用过，但是觉得没理解为什么会有这个框架，用得也是稀里糊涂，所以最近开始从文档看起。</p>
<p>在这个工程的<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">首页</a>，看到了这句话：</p>
<blockquote>
<p>ReactiveCocoa (RAC) is an Objective-C framework inspired by Functional Reactive Programming. It provides APIs for composing and transforming streams of values.</p>
</blockquote>
<p>FRP(Functional Reactive Programming)这是个新名词（对我来说），从名字上来看是和函数式编程和响应式编程相关，但这两个我都不了解，于是又去查资料，看看什么是FRP。没有找他详细的介绍，只在<a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">wiki</a>上找到了一个简单定义。但还是不理解啊。</p>
<p>于是继续看它的文档：<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/DesignGuidelines.md" target="_blank" rel="external">Design Guide</a>，发现了这句话：</p>
<blockquote>
<p>This document contains guidelines for projects that want to make use of ReactiveCocoa. The content here is heavily inspired by the Rx Design Guidelines.</p>
</blockquote>
<p>似乎看到了希望，从微软的网站下载了<a href="http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx" target="_blank" rel="external">Rx Design Guidelines</a>。一番折腾之后似乎总算找到了源头，但其实还应该看Functional Programming，但最近还没有看FP的计划啊，看来要加快速度了。</p>
<p>关于Rx（Reactive Extension），可以参考微软的<a href="https://msdn.microsoft.com/en-us/data/gg577609" target="_blank" rel="external">网站</a>，其中对Rx的定义如下：</p>
<blockquote>
<p>is a library to compose asynchronous and event-based programs using observable collections and LINQ-style query operators.</p>
</blockquote>
<p>由于我们要学习的是Reactive，所以可以暂时忽略其中涉及到的微软的名称，比如LINQ，翻译一下（由于不了解，所以翻译的并不准确）：</p>
<blockquote>
<p>Rx作为一个库，通过提供观察、查询数据流的功能，从而可以组成一个异步的、基于事件的程序。</p>
</blockquote>
<p>也就是说首先使用Rx写的程序，应该是一个基于事件的，类似与Node.js，同时是异步的，这一点也类似Node.js，我想理解这两点是使用Rx的基础。<br>关于LINQ，可以类比为SQL，提供了对数据集的操作。</p>
<p>另外一个要提到中是scheduler，在网站上有这样一个公式：</p>
<blockquote>
<p>Rx = Observables + LINQ + Schedulers.</p>
</blockquote>
<p>scheduler主要是用在多线程中控制数据流的。</p>
<p>关于Rx，还是需要仔细读读Rx Design Guidelines这个文档吧。</p>
<p>另外，感觉Rx和Promise很像，在网上找到了<a href="http://rmod.lille.inria.fr/archives/dyla13/dyla13_6_Evaluation_Reactive_Programming_Web_Apps.pdf" target="_blank" rel="external">这篇论文</a>，可以好好看看。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/03/02/GODEBUG/">
  <time datetime="2015-03-02T03:48:24.000Z">
    Mar 2 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/03/02/GODEBUG/">GODEBUG</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>最近在看Go语言的时候，一直好奇环境变量是如何传人的，今天在Go <a href="http://golang.org/pkg/runtime/" target="_blank" rel="external">runtime</a>文档中看到了一点信息。</p>
<p>传人的方式就是在启动Go程序的命令行前面加上要设置的环境变量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOMAXPROCS=2 go run main</span><br></pre></td></tr></table></figure></p>
<p>注意在文档中介绍了GODEBUG这个环境变量，可以在开发阶段使用，来打印gc相关的一些信息，这样对于我们调试程序很有帮助。<br>比如使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=schedtrace=1000 go run main</span><br></pre></td></tr></table></figure></p>
<p>就可以打印出类似下面的东东：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs=1 idleprocs=0 threads=2 spinningthreads=0 idlethreads=0 runqueue=0 [1]&#10;SCHED 1001ms: gomaxprocs=1 idleprocs=1 threads=3 spinningthreads=0 idlethreads=1 runqueue=0 [0]&#10;SCHED 2008ms: gomaxprocs=1 idleprocs=0 threads=3 spinningthreads=0 idlethreads=1 runqueue=0 [9]&#10;SCHED 3015ms: gomaxprocs=1 idleprocs=0 threads=3 spinningthreads=0 idlethreads=1 runqueue=0 [9]</span><br></pre></td></tr></table></figure></p>
<p>打印的主要是runtime内部的调度信息，如有多少个线程，有多少routine在运行，有多少在等待，等等。</p>
<p>而使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=gctrace=1 go run main</span><br></pre></td></tr></table></figure></p>
<p>就可以打印gc相关的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc1(1): 0+0+56+0 us, 0 -&#62; 0 MB, 21 (21-0) objects, 2 goroutines, 15/0/0 sweeps, 0(0) handoff, 0(0) steal, 0/0/0 yields</span><br></pre></td></tr></table></figure></p>
<p>另外，也要关注一些runtime的下的子包，如：debug等。学习中。。。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/02/20/Promise-A-in-javascript/">
  <time datetime="2015-02-20T03:40:25.000Z">
    Feb 20 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/02/20/Promise-A-in-javascript/">Promise/A+ in javascript</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>之前我们讨论了Promise，但如果在网上仔细搜索的话，还会发现<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+</a>，仔细看过这个网站的内容就会发现，其实Promise/A+是Promise/A的一个补充，或者说实施细则。应该是在参照CommonJS的Promise/A使用了一段时间之后，对原有规范的细化，比如增加了thenable，对then方法的内部处理提出了更详细的规定。</p>
<p>另外，Javascript的下一个版本ECMAScript 6也将支持对Promise的原生支持，可以看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Mozilla的实现</a></p>
<p>其实在实现Promise的时候，除了then，各个lib也会加入一些方便使用的方法，如when，all等。推荐几个比较流行的实现：</p>
<ul>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a></li>
<li><a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a></li>
<li><a href="http://jquery.com/" target="_blank" rel="external">jQuery</a></li>
<li><a href="https://github.com/tildeio/rsvp.js" target="_blank" rel="external">RSVP</a></li>
</ul>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/02/17/promise-in-javascript/">
  <time datetime="2015-02-17T07:18:38.000Z">
    Feb 17 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/02/17/promise-in-javascript/">promise in javascript</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>在刚开始写Node.js代码的时候，最头疼的就是缩进了，其实是由于回调导致的，因为Node.js是异步编程的，几乎所有的逻辑都是靠异步调用实现的。这也是和我们常用的同步编程最大的却别。</p>
<p>后来在使用其他的框架的使用，比如JQeury的ajax，AngularJS的时候也用过其中实现的promise，不过那是还不知道那就是promise，所以对于为什么使用then，done，when，只是照着例子写代码就是了。最近觉得应该看一下什么是promise，所以就找到了promise的源头：<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="external">Promise/A</a>，看了一下其中的定义，终于明白了什么是then，以及应该怎么使用。</p>
<p>其实在使用其他的promise实现的时候还会遇到when，done之类的方法，这些方法是用来做什么的呢？可以看看这篇关于<a href="http://www.infoq.com/cn/news/2011/09/js-promise/" target="_blank" rel="external">JS Promise</a>的文章。如果有空的话也可以自己现实一个promise，看看和现有的实现<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a>，<a href="https://github.com/tildeio/rsvp.js" target="_blank" rel="external">RSVP</a>，<a href="https://github.com/cujojs/when" target="_blank" rel="external">when</a>有哪些差距。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/02/11/invalid-recursive-type-struct/">
  <time datetime="2015-02-11T03:39:38.000Z">
    Feb 11 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/02/11/invalid-recursive-type-struct/">invalid recursive type struct</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>用惯了面向对象编程的语言，认为一切都是指针之后，再切换到Go这种语言真是不习惯啊。今天定义了一个structure：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="typename">float32</span></span><br><span class="line">    y <span class="typename">float32</span></span><br><span class="line">    next Point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后编译报错：invalid recursive type struct…</p>
<p>查了一下才明白，因为struct是值类型，如果这样的定义的话就形成了以无限循环，每一个Point会包含一个Point，所以解决方法就是改成指针：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="typename">float32</span></span><br><span class="line">    y <span class="typename">float32</span></span><br><span class="line">    next *Point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为指针是固定大小的，也可以是nil，所以这就没问题了。</p>
<p>嗯小白。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/02/04/Constants-in-Objective-C/">
  <time datetime="2015-02-04T03:41:43.000Z">
    Feb 4 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/02/04/Constants-in-Objective-C/">Constants in Objective-C</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>在Objective-C中定义常量的方式一般有如下几种：</p>
<ul>
<li>#define</li>
<li>const</li>
<li>static const</li>
<li>extern const</li>
<li>FOUNDATION_EXPORT const</li>
</ul>
<p>这几中方式有什么不同呢？我们应该使用那种呢？</p>
<h2 id="23define"><a href="#23define" class="headerlink" title="#define"></a>#define</h2><p>从C中继承来的，不过已经不再推荐使用了，因为define属于预编译指令，编译器会在生成的代码中替换掉定义的常量，那么其实它定义的不是一个变量，只是一个用来替换的代码块。这就给调试带来了麻烦。另外也有人用define定义函数，甚至紧紧是几行经常重复的代码块，其实这更容易出现问题，如果学过C语言的一般都应该看过define定义函数有哪些坑吧。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>适合用来定义局部常量，比如在一个代码块里，或者在一个实现文件里（.m文件）</p>
<h2 id="static_const"><a href="#static_const" class="headerlink" title="static const"></a>static const</h2><p>适合用来定义文件内的常量，通常定义在实现文件里，由于static修饰，只能用在改文件内，外部无法获取。（也可以在方法内或一个代码块内声明static 变量，那么它的作用域就是当前声明所在的域，外部不可见，但是一直存在，不被销毁）</p>
<h2 id="extern_const"><a href="#extern_const" class="headerlink" title="extern const"></a>extern const</h2><p>如果定义的常量给外部类，文件使用的，则应该使用extern，使得变量（也可以应用于方法）在外部可见。</p>
<h2 id="FOUNDATION_EXPORT_const"><a href="#FOUNDATION_EXPORT_const" class="headerlink" title="FOUNDATION_EXPORT const"></a>FOUNDATION_EXPORT const</h2><p>如果你的代码是和C/C++混编的，为了使声明的变量在其他文件中可以，应该使用这种方式，其他情况下和extern的作用一样。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/01/29/Questions-for-interface-in-Go/">
  <time datetime="2015-01-29T03:49:57.000Z">
    Jan 29 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/01/29/Questions-for-interface-in-Go/">Questions for interface in Go</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>刚刚开始学习<a href="https://golang.org" target="_blank" rel="external">Go</a>，最近看到<a href="http://avtok.com/2014/11/05/interface-upgrades.html" target="_blank" rel="external">一篇关于Go interface的文章</a>。<br>虽然挺喜欢GO的，但是文章里说的关于interface的一些优点，想想在其他语言里也基本都有啊，比如：</p>
<ul>
<li><blockquote>
<p>interfaces be safely cast to narrower interfaces (i.e., every io.ReadCloser is also an io.Reader), but they can also be cast to wider or even unrelated interfaces if their dynamic types support it.<br>在Java也可以随意cast啊，不是么？如果说的是<code>instance.(type)</code>这种cast写法比较方便，那也算不上interface的优势吧？更安全？Java或其他高级语言也可以在cast之前进行类型判断</p>
</blockquote>
</li>
<li><blockquote>
<p>Supporting this kind of copy elision in io.Copy is tricky since we can’t change the signature of either io.Reader.Read or io.Writer.Write without sacrificing generality. Luckily, interface upgrades come to our rescue. The io package defines two auxiliary types, io.WriterTo and io.ReaderFrom which io.Readers and io.Writers (respectively) may optionally implement.<br>真心没看懂啊，不都是cast么？难道这个不用cast？</p>
</blockquote>
</li>
</ul>
<p>唉，剩下的就不一个一个说了，基本上我觉得其他的常用语言也都能做到，虽然我挺喜欢Go的，但目前主要是觉得确实可以少写很多不必要的东西，比如变量类型啊，分号啊之类的，看来我还在初级阶段，真的没看到这篇文章里的东西和其他语言比有多高级。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/01/27/variable-arguments-in-Objective-C/">
  <time datetime="2015-01-27T07:59:50.000Z">
    Jan 27 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/01/27/variable-arguments-in-Objective-C/">variable arguments in Objective-C</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p><a href="http://www.cocoawithlove.com/2009/05/variable-argument-lists-in-cocoa.html" target="_blank" rel="external">http://www.cocoawithlove.com/2009/05/variable-argument-lists-in-cocoa.html</a><br>在Objective-C中我们经常会用到这样方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = [NSString stringWithFormat:@&#34;test %@ arguments&#34;, @&#34;variable&#34;];</span><br></pre></td></tr></table></figure></p>
<p>在这个方法里，可以传人一个或多个参数，这就是可变参数。</p>
<p>在Objective-C中有两种可变参数：</p>
<ul>
<li>需要以nil结尾的</li>
<li>不需要以nil结尾的</li>
</ul>
<p>format string就属于不需要nil结尾的。而像NSArray的初始化方法就是需要nil结尾的。为什么会有这种区分呢？因为我们需要知道传入参数的具体数量，虽然在传参的时候可以是任意数量的，但处理这些参数时仍然需要知道具体的数量。像format string这种由于可以使用format来判断需要的参数个数，所以就不需要nil结尾了，否则就得有nil来告诉处理程序–参数传完了。</p>
<p>下面看一下这两种类型的变参是如何声明的吧：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//without nil&#10;- (void)addContents:(NSString *)obj, ...;&#10;&#10;//with nil&#10;- (void)addContentsWithNil:(NSString *)obj, ... NS_REQUIRE_NIL_TERMINATION;</span><br></pre></td></tr></table></figure></p>
<p>需要nil的多了一个宏：NS_REQUIRE_NIL_TERMINATION，编译器看到这个宏也会检查这个方法的调用是不是包含了nil结尾。</p>
<p>而读取可变参数就要用到C中方法了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addContents:(NSString *)obj, ...&#10;&#123;&#10;    //assume we have got the number of arguments&#10;    int vaCount = 7;&#10;    va_list args;&#10;    va_start(args, obj);&#10;    NSString arg = obj;&#10;    for (int i = 0; i &#60; vaCount; ++i) &#123;&#10;        ...//use the arg&#10;        arg = va_arg(args, NSString *);&#10;    &#125;&#10;    va_end(args);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>va_list是数据类型，表示了可变参数</li>
<li>va_start将声明的va_list指向了可变参数</li>
<li>va_arg获取可变参数中的下一个参数</li>
<li>va_end释放内存</li>
</ul>
<p>如果以nil结尾的可变参数，则在循环的过程中判断获得的参数是不是nil就行了。</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/01/27/interface-in-Go/">
  <time datetime="2015-01-27T04:25:44.000Z">
    Jan 27 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/01/27/interface-in-Go/">interface in Go</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>最近看了<a href="http://research.swtch.com/interfaces" target="_blank" rel="external">Go Data Structure</a>，对interface了解多了一点。下面简单翻译一下重点：</p>
<p>Go中的interface既做到了隐式继承，又做到了编译期检查，前者是静态语言做不到的，而后者是很多动态语言做不到了，所以可以看到Go在编程语言的位置，位于中间。</p>
<p>interface value是有一个包含两个字段的structure表示的，第一个字段是指向了interface的类型信息，包括方法等，第二个字段指向了真实的数据。<em>注意：</em>原文中使用word表示字段，所以这个代表interface value的structure可能也不是我们理解的严格意义上的structure，而用word表示的应该是计算机中的一个字，如果是32位的机器，word表示的就是32位，如果是64位的机器，word表示的就是64位。</p>
<p>有如下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">        String() <span class="typename">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="typename">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (i Binary) String() <span class="typename">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strconv.Uitob64(i.Get(), <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> (i Binary) Get() <span class="typename">uint64</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="typename">uint64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>做如下赋值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Stringer = b</span><br></pre></td></tr></table></figure></p>
<p>那么内存中是这样的(借用原文的图了:))：<br><img src="http://research.swtch.com/gointer2.png" alt="structure in memory"></p>
<p>图中的itable表示是interface的itable，而不是实际类型的itable。在这个例子中，itable表示的是Stringer的itable，而不是Binary的。</p>
<blockquote>
<p>(由于interface仅相当于一个类型声明，而没有实例变量等内容，所以这个itable应该是全局唯一的，不过这也和方法查找有关，如果interface的方法与实际类型的方法之间对应关系是和这个itable相关的，那么就不能是全局唯一的了。否则如果多个类型实现了Stringer interface，就没法保持之前建立的对应关系了。)忘掉这段吧，因为itable里有指向实际类型的指针（指向Binary）</p>
</blockquote>
<p>另外一点要注意的是itable中的方法是(* Binary).String()，而不是Binary.String()。因为第二个字段data保持的是指向实际类型（Binary）的指针，也就是说可以认为data中保持的是* Binary。（<em>这是不是就是指向某个类型的指针会包含该类型的所有方法的原因呢？</em>，如果是这样的话，其实调用的时候可以用(*data).String()，而不是直接data.String()，嗯，不过等到做内存优化的时候就有问题了，优化过之后data保持的可能就是实际的值，而不是指针了）</p>
<p>以前在看到下面这样的代码时都会疑惑：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> doSomething(a <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> a != <span class="constant">nil</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果传入的a是一个primitive类型怎么办？为什么可以用nil来判断0值呢？<br>其实不管传入的是什么类型，最后都会转换位interface</p>
<p>最后，有句话没看懂啊，求教：</p>
<blockquote>
<p>Because Go has the hint of static typing to go along with the dynamic method lookups, it can move the lookups back from the call sites to the point when the value is stored in the interface.</p>
</blockquote>
<p>最后的最后，看起来Go的runtime和Objective-C的挺像的（<em>看起来</em>）那是不是就像Objective-C一样，使用了类似@selector的方式做方法查找，而导致不能做方法重载呢？</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2015/01/27/KVO-in-Objective-C/">
  <time datetime="2015-01-27T04:25:08.000Z">
    Jan 27 2015
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/2015/01/27/KVO-in-Objective-C/">KVO in Objective-C</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Key-Value-Observing，KVO，提供一种机制，可是使任何一个对象监听另一个对象的状态变化，只要被监听对象实现了NSKeyValueObserving protocol。关于KVO的争议有很多，不过这里只讨论一下如何正确的使用KVO。</p>
<p>使用KVO包括三个步骤</p>
<ul>
<li>订阅：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[objectA addObserver:self&#10;          forKeyPath:@&#34;path&#34;&#10;             options:NSKeyValueObservingOptionNew&#10;             context:NULL];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里使用了self作为observer</p>
<ul>
<li><p>响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#10;&#123;&#10;  if ([keyPath isEqualToString:kSearchBarKVOObserverContentOffset]) &#123;&#10;      [self scrollViewDidScroll:object];&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消订阅：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[objectA removeObserver:self forKeyPath:@&#34;path&#34;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来看看有什么需要改进的：</p>
<ol>
<li><p>在响应函数里，应该调用super，否则super的KVO就不会响应了，所以的改成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#10;&#123;&#10;  if ([keyPath isEqualToString:kSearchBarKVOObserverContentOffset]) &#123;&#10;      [self scrollViewDidScroll:object];&#10;  &#125; else &#123;&#10;      [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是这样的判断并不保险，也许super也订阅了@”path”呢，所以这时应该用context来区分:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;static void * KVOContext = &#38;KVOContext;&#10;&#10;    [objectA addObserver:self&#10;              forKeyPath:@&#34;path&#34;&#10;                 options:NSKeyValueObservingOptionNew&#10;                 context:KVOContext];&#10;&#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#10;&#123;&#10;  if (context == KVOContext) &#123;&#10;      if ([keyPath isEqualToString:kSearchBarKVOObserverContentOffset]) &#123;&#10;          [self scrollViewDidScroll:object];&#10;      &#125;&#10;  &#125; else &#123;&#10;      [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里的context其实只是一个标识，所以也就仅仅需要一个地址就可以了，不需要有任何的实际意义。</p>
<ol>
<li><p>keyPath用的是NSString，但如果有什么拼写错误就麻烦了，编译器也无法发现，所以最好是使用selector：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString keyPath = NSStringFromSelector(@selector(path));</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消订阅时，如果给的observer没有订阅过，系统就会抛出异常（不是返回error），也就是会crash，所以需要用try catch：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;&#10;    [objectA removeObserver:self forKeyPath:@&#34;path&#34;];&#10;&#125; @catch (NSException * __unused exception) &#123;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>好了，经过一番折腾之后，差不多可以安心使用KVO了，麻烦么？</p>

    
  </div>
  <footer class="end-sep">
    
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  <nav id="pagination">
  
  
    <a href="/archives/2015/page/2/" class="next">下一页</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2016 <a href="/">Jinyu Li</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var duoshuoQuery = { short_name: 'mrsnippet' };
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>